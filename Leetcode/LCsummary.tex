\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{color}
\begin{document}
\title{
{Summary for LC alg problems}
}
\author{Baigong Zheng}
\date{}
\maketitle
\begin{abstract}
I will try to summarize the methods, the code will not be here.
\end{abstract}

\paragraph{507}
Try every possible number in $[2, \sqrt num]$. If $i$ is a divisor, then subtract $i$ and $num/i$. 
Running time is $O(\sqrt n)$.

\paragraph{514}
We solve this by dynamic programming.
The state dp[i][j] is the minimum step to finish matching the first $i$ letter and the ring stops at the position $j$ and 
this position $j$ has the same letter as the $i$-th letter in the key. This can be obtained from dp[i-1][:] by trying the 
two direction rotation. To improve the running time a little bit, We use dictionary instead of list to store dp[i][j] and
we only store those position $j$ that has the matched letter for dp[i].
The running time is $O(n^3)$.

\paragraph{517}
This can be solved in a greedy way. 
First compute the target number of dresses: the final number of dresses in each machine should be the same, so it is just total number divided by number of machines. If not an integer, then impossible.
Start from beginning (the leftmost machine), for the current machine $i$, record the number of moves to make it have target number of dresses: if it has more than target, then move all the additional dresses from it to $i+1$; if less than target, then move all needed dresses from $i+1$ to it. 
Record this number of moves in $count$ array and update the number of dresses in machine $i+1$.
The result is the maximum in $count$.
The running time is $O(n)$.
This could work since each number in $count$ is a lower bound for the machine, which is feasible. (Can be proved by induction: the first $i$ machines have optimal moves and we do not need to worry about them.)
BFS could work, but the running time is too big since the number of states are very big.

\paragraph{521}
We do not need to consider subsequence, the candidate should be the entire string. Then the problem is simplified. If the length of the two strings are different, return the bigger length. Otherwise if the two strings are different, return 
the length of any one, othwerwise return -1. 

\paragraph{522}
Notice that the candidate should only be the entire string, not its proper subsequence.
This is because if the candidate has a proper subsequence satisfying the condition, the candidate string also satisfies the 
condition. So we only consider each entire string and check if it is subsequence of other strings. 
Before comparing strings, we sort the strings according to their lengths. Take care of the iter() funciton. 
The running time is $O(mn)$, where $n$ is the number of strings, and $m$ is the length of the longest string.



\paragraph{523}
For each index $i$, we first compute the sum from 0 to $i$ and then modulo $k$. We record this number $x_i$ for each index in a dict.
For current index $j$, we check $x_j$: if $x_j$ first appears at $i$ before and $j - i > 1$, then output True; or if $x_j == 0$ and $j > 0$, then output True.
The boundary case is $k = 0$, we need to check if there are two adjacent 0's.
This needs $O(n)$ time and $O(k)$ space.
 
\paragraph{524}
Sort the list into such that the list is decreasing in the length of the string and for the same length it is sorted in lexicographical order.
Then test each string in this order: if it is a substring of input string $s$ then output the current tested string.
This needs $O(nm + d \log d)$ time, where $n$ and $m$ are the length of input strings and $d$ is the size of the list.

\paragraph{525}
Preprocess the numbers: change 0 to -1.
Then the interval containing same numbers of 1 and -1 has sum 0.
Now loop the array and compute the sum from 0 to current index. 
We record the first index for each distinct sum value by a hash map.
When the sum appears again, we can find the target interval by the recored first index for that sum.
This runs in $O(n)$ time.

My first try is binary search on the length of the interval, but that does not work, since the result is not contiguous in the lengths. That is, if there is an interval of length $l$, then the subinterval of length $l-2$ may not be a feasible solution. Example: $000111111000$.


\paragraph{526}
Find all the possible numbers for each position (that are divisors and multiples), and then use DFS to try each possible arrangement.
I'm not sure about the complexity. 

\paragraph{527}
Try all possible abbreviations. Store the all abbreviations in a dictionary: key is the abbreviation and the value is a list
containing all the indices of the words in the input whose abbreviation is the key. When the length of a key is larger than 
one, we try to increase the prefix. Try all the prefix and when the key is uniquely used, add it into answer list.


\paragraph{529}
Reveal the current cell if it is an unrevealed mine.
Otherwise, check its neighbors (at most 8) and if there is no mine then update it according to the rule and recursively do this for its neighbors; if there is mine as its neighbor, then count the number and update current cell as number.

\paragraph{530}
Collect all the values into a set, and then transform that into a list.
Sort the list and then check each two adjacent values to find the minimum absolute difference. 
The running time is $O(n \log n)$.
My first try is to enumerate all pairs without sorting, which gives a TLE.

\paragraph{531}
First count the numbers of 'B' for each column and each row. Then use this information to count the target 'B'.
Running time $O(n^2)$.


\paragraph{532}
Store the numbers in a dictionary and count their frequency so we can easily check if the target is in the list. 
Then store the result pairs in a set and return the length of the set. Take care of the corner cases when $k = 0$ 
and $k$ is negtive.
Running time is $O(n)$.


\paragraph{533}
First count the number of 'B' for each column and each row. Then compare each pair of rows and count the number of same rows
for each row. With these information, we can check for each column with $N$ 'B's if there are $N$ same rows with 'B' in that 
column. 
Running time is $O(n^3)$ where $n$ is the max length of the row and column. If we transfer each row into a string and use hash to count the number of same strings, the running time could be $O(n^2)$.

\paragraph{536}
add the first number in the root, and then parse the string to find the next two strings for the subtrees. To parse the 
string, just count the number of parenthesis: when the numbers are equal, the parse is done. Recursively solve the substrings.

\paragraph{537}
Simulate the computation.

\paragraph{538}
Traverse the tree to collect all values in the tree and sort those in dicresing order. For each value $val$, store the sum of 
all values larger than $val$ in the dictionary indexed by $val$. Update the values in the tree by this dictionary.
Running time is $O(n \log n)$.

\paragraph{539}
Convert the time into a integer, then sort the list and compare the adjacent two numbers. Don't forget to comopare the first
and the last number. The distance between two numbers is the min of the absolute difference and 1440 - the abs difference.

\paragraph{541}
Just reverse the required substrings.

\paragraph{542}
Breadth first search for the distance. Running time is $O(n)$.

\paragraph{543}
Traverse the tree and return the longest distance in the current subtree and the lenght of the deepest path in current subtree. The answer is the maximum of the two values of the root.

\paragraph{544}
First construct the sequence of the numbers iteratively, and then convert the numbers into strings recersively.
First compute the number of roundes, which is the exponent of 2 for $n$. To construct the numbers, for the $i$th round, we start from last sequence of numbers $S^i$. For each number $x$ in $S^i$, we add $x$ and a new number $2^i+1 - x$ after $x$.
The new sequence $S^{i+1}$ has length twice as $S^i$. The base case is $i = 0$, where $S^0 = \{ 1 \}$.
After the construction, we recersively combine the numbers into strings. Each time we divide the sequence into two halves 
and then combine the strings from the two subsequences into a new string. The base case is when there are only two numbers.
The running time is $O(n)$.

\paragraph{545}
Search each boundary and then follow the rules to combine them. Take care of the corner cases.

\paragraph{546}
Dynamic programming. The state $dp[i][j][k]$ stores the max points we can get from $i$th boxes to $j$th boxes (both inclusive) 
with additional $k$ boxes of the same value as the $j$th box on the right of the $j$th box. For example, dp[1][3][2] 
is the max points from the state $\{b_1, b_2, b_3, X, X \}$ where $X = b_3$. 
The transformation is $dp[i][j][k] = \max \{dp[i][x][k+1] + dp[x+1][j-1][0], dp[i][j][k] \}$ where $boxes[x] == boxes[j]$.
If there is no such $x$, then $dp[i][j][k] = dp[i][j-1][0] + (k+1)^2$.
The running time is $O(n^4)$. 
To pass all the tests, we also need some optimization. That is, when there are consecutive same values, we want to choose $x$
as the left index, instead of trying every position. But when there are not consecutive intervals, we still need to try each 
of them.

\paragraph{547}
Union-find sets. Scan the input graph and union two friend sets. Return the number of final sets. We use the minimum number
in the set as its representative. 


\paragraph{548}
Divide and conquer. Enumerate each possible index $j$. For each $j$, split the array into two parts. For each such part, 
enumerate the split index and store the sum if the two subarray have the same sum. When there exists a stored value 
from both parts, return true, otherwise false.
Running time $O(n^2)$ since for each $j$, the computation can be done in linear time.


\paragraph{549}
Dynamic programming on tree. The state is a tuple of three lengths: the longest consecutive path less or equal to the root 
value, the longest consecutive path greater or equal to the root value, and the longest consecutive path in the subtrees 
without current root. The running time is linear.

\paragraph{554}
If the line crosses least bricks, then that is where most lines can be split. That is, we want to find a number that can split
most rows. For each row, the number is the sum of the bricks on the left of the line. We count such sums for all rows in 
a dictionary and choose the max value. The running time is linear to the number of bricks.


\paragraph{556}
Similar to find the next permutation. Transform the number into a list of digits. 
Find the longest increasing sequence from the end and then process this sequence.
Assume this sequence is $A[i:]$, then find the smallest element $A[j]$ in this sequence that is larger than $A[i-1]$ and swap
them. Next, sort $A[i:]$ and transform the list back to the number. Take care of the corner case.

\paragraph{557}
String processing. Split the intput into words, reverse the words and then join them by space.


\end{document}
