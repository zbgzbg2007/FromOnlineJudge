\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{color}
\begin{document}
\title{
{Summary for LC alg problems}
}
\author{Baigong Zheng}
\date{}
\maketitle
\begin{abstract}
I will try to summarize the methods, the code will not be here.
\end{abstract}

\paragraph{502}
This could be solved by heap. We can use two heaps $heap1$ and $heap2$: $heap1$ (max heap) storing the profits of the projects 
whose capital is less than our current capital $W$ and $heap2$ (min heap for capital) storing the capitals and profits whose
capital is more than $W$. Each time we choose the top of $heap1$ to add into our solution and then update $W$. 
Then we pop all possible projects from $heap2$ and push them to $heap1$. After $k$ times, the $W$ is the answer.
We could also just use one max heap (that is the same as $heap1$ above). We first construct an array whose elements are the tuple
(profit, capital) of all projects. And then we sort the array by capital. 
Now for each of the $k$ iterations, we only need to pop all possible projects in the array and then push them to the max heap. 
Since the array is sorted by capitals, we have all possible projects in our heap.
Note that the pop operation only needs $O(1)$ time for list.
The running time is $O(n \log n)$ where $n$ is the total number of projects. This is because for two heaps we push all of them 
into heaps, and for one heap we sort all the projects.

\paragraph{507}
Try every possible number in $[2, \sqrt num]$. If $i$ is a divisor, then subtract $i$ and $num/i$. 
Running time is $O(\sqrt n)$.

\paragraph{514}
We solve this by dynamic programming.
The state dp[i][j] is the minimum step to finish matching the first $i$ letter and the ring stops at the position $j$ and 
this position $j$ has the same letter as the $i$-th letter in the key. This can be obtained from dp[i-1][:] by trying the 
two direction rotation. To improve the running time a little bit, We use dictionary instead of list to store dp[i][j] and
we only store those position $j$ that has the matched letter for dp[i].
The running time is $O(n^3)$.

\paragraph{517}
This can be solved in a greedy way. 
First compute the target number of dresses: the final number of dresses in each machine should be the same, so it is just total number divided by number of machines. If not an integer, then impossible.
Start from beginning (the leftmost machine), for the current machine $i$, record the number of moves to make it have target number of dresses: if it has more than target, then move all the additional dresses from it to $i+1$; if less than target, then move all needed dresses from $i+1$ to it. 
Record this number of moves in $count$ array and update the number of dresses in machine $i+1$.
The result is the maximum in $count$.
The running time is $O(n)$.
This could work since each number in $count$ is a lower bound for the machine, which is feasible. (Can be proved by induction: the first $i$ machines have optimal moves and we do not need to worry about them.)
BFS could work, but the running time is too big since the number of states are very big.

\paragraph{521}
We do not need to consider subsequence, the candidate should be the entire string. Then the problem is simplified. If the length of the two strings are different, return the bigger length. Otherwise if the two strings are different, return 
the length of any one, othwerwise return -1. 

\paragraph{522}
Notice that the candidate should only be the entire string, not its proper subsequence.
This is because if the candidate has a proper subsequence satisfying the condition, the candidate string also satisfies the 
condition. So we only consider each entire string and check if it is subsequence of other strings. 
Before comparing strings, we sort the strings according to their lengths. Take care of the iter() funciton. 
The running time is $O(mn)$, where $n$ is the number of strings, and $m$ is the length of the longest string.



\paragraph{523}
For each index $i$, we first compute the sum from 0 to $i$ and then modulo $k$. We record this number $x_i$ for each index in a dict.
For current index $j$, we check $x_j$: if $x_j$ first appears at $i$ before and $j - i > 1$, then output True; or if $x_j == 0$ and $j > 0$, then output True.
The boundary case is $k = 0$, we need to check if there are two adjacent 0's.
This needs $O(n)$ time and $O(k)$ space.
 
\paragraph{524}
Sort the list into such that the list is decreasing in the length of the string and for the same length it is sorted in lexicographical order.
Then test each string in this order: if it is a substring of input string $s$ then output the current tested string.
This needs $O(nm + d \log d)$ time, where $n$ and $m$ are the length of input strings and $d$ is the size of the list.

\paragraph{525}
Preprocess the numbers: change 0 to -1.
Then the interval containing same numbers of 1 and -1 has sum 0.
Now loop the array and compute the sum from 0 to current index. 
We record the first index for each distinct sum value by a hash map.
When the sum appears again, we can find the target interval by the recored first index for that sum.
This runs in $O(n)$ time.

My first try is binary search on the length of the interval, but that does not work, since the result is not contiguous in the lengths. That is, if there is an interval of length $l$, then the subinterval of length $l-2$ may not be a feasible solution. Example: $000111111000$.


\paragraph{526}
Find all the possible numbers for each position (that are divisors and multiples), and then use DFS to try each possible arrangement.
I'm not sure about the complexity. 

\paragraph{527}
Try all possible abbreviations. Store the all abbreviations in a dictionary: key is the abbreviation and the value is a list
containing all the indices of the words in the input whose abbreviation is the key. When the length of a key is larger than 
one, we try to increase the prefix. Try all the prefix and when the key is uniquely used, add it into answer list.


\paragraph{529}
Reveal the current cell if it is an unrevealed mine.
Otherwise, check its neighbors (at most 8) and if there is no mine then update it according to the rule and recursively do this for its neighbors; if there is mine as its neighbor, then count the number and update current cell as number.

\paragraph{530}
Collect all the values into a set, and then transform that into a list.
Sort the list and then check each two adjacent values to find the minimum absolute difference. 
The running time is $O(n \log n)$.
My first try is to enumerate all pairs without sorting, which gives a TLE.

\paragraph{531}
First count the numbers of 'B' for each column and each row. Then use this information to count the target 'B'.
Running time $O(n^2)$.


\paragraph{532}
Store the numbers in a dictionary and count their frequency so we can easily check if the target is in the list. 
Then store the result pairs in a set and return the length of the set. Take care of the corner cases when $k = 0$ 
and $k$ is negtive.
Running time is $O(n)$.


\paragraph{533}
First count the number of 'B' for each column and each row. Then compare each pair of rows and count the number of same rows
for each row. With these information, we can check for each column with $N$ 'B's if there are $N$ same rows with 'B' in that 
column. 
Running time is $O(n^3)$ where $n$ is the max length of the row and column. If we transfer each row into a string and use hash to count the number of same strings, the running time could be $O(n^2)$.

\paragraph{536}
add the first number in the root, and then parse the string to find the next two strings for the subtrees. To parse the 
string, just count the number of parenthesis: when the numbers are equal, the parse is done. Recursively solve the substrings.

\paragraph{537}
Simulate the computation.

\paragraph{538}
Traverse the tree to collect all values in the tree and sort those in dicresing order. For each value $val$, store the sum of 
all values larger than $val$ in the dictionary indexed by $val$. Update the values in the tree by this dictionary.
Running time is $O(n \log n)$.

\paragraph{539}
Convert the time into a integer, then sort the list and compare the adjacent two numbers. Don't forget to comopare the first
and the last number. The distance between two numbers is the min of the absolute difference and 1440 - the abs difference.

\paragraph{541}
Just reverse the required substrings.

\paragraph{542}
Breadth first search for the distance. Running time is $O(n)$.

\paragraph{543}
Traverse the tree and return the longest distance in the current subtree and the lenght of the deepest path in current subtree. The answer is the maximum of the two values of the root.

\paragraph{544}
First construct the sequence of the numbers iteratively, and then convert the numbers into strings recersively.
First compute the number of roundes, which is the exponent of 2 for $n$. To construct the numbers, for the $i$th round, we start from last sequence of numbers $S^i$. For each number $x$ in $S^i$, we add $x$ and a new number $2^i+1 - x$ after $x$.
The new sequence $S^{i+1}$ has length twice as $S^i$. The base case is $i = 0$, where $S^0 = \{ 1 \}$.
After the construction, we recersively combine the numbers into strings. Each time we divide the sequence into two halves 
and then combine the strings from the two subsequences into a new string. The base case is when there are only two numbers.
The running time is $O(n)$.

\paragraph{545}
Search each boundary and then follow the rules to combine them. Take care of the corner cases.

\paragraph{546}
Dynamic programming. The state $dp[i][j][k]$ stores the max points we can get from $i$th boxes to $j$th boxes (both inclusive) 
with additional $k$ boxes of the same value as the $j$th box on the right of the $j$th box. For example, dp[1][3][2] 
is the max points from the state $\{b_1, b_2, b_3, X, X \}$ where $X = b_3$. 
The transformation is $dp[i][j][k] = \max \{dp[i][x][k+1] + dp[x+1][j-1][0], dp[i][j][k] \}$ where $boxes[x] == boxes[j]$.
If there is no such $x$, then $dp[i][j][k] = dp[i][j-1][0] + (k+1)^2$.
The running time is $O(n^4)$. 
To pass all the tests, we also need some optimization. That is, when there are consecutive same values, we want to choose $x$
as the left index, instead of trying every position. But when there are not consecutive intervals, we still need to try each 
of them.

\paragraph{547}
Union-find sets. Scan the input graph and union two friend sets. Return the number of final sets. We use the minimum number
in the set as its representative. 


\paragraph{548}
Divide and conquer. Enumerate each possible index $j$. For each $j$, split the array into two parts. For each such part, 
enumerate the split index and store the sum if the two subarray have the same sum. When there exists a stored value 
from both parts, return true, otherwise false.
Running time $O(n^2)$ since for each $j$, the computation can be done in linear time.


\paragraph{549}
Dynamic programming on tree. The state is a tuple of three lengths: the longest consecutive path less or equal to the root 
value, the longest consecutive path greater or equal to the root value, and the longest consecutive path in the subtrees 
without current root. The running time is linear.

\paragraph{551}
For 'A', we count the number; for 'L', we check if there is a substring of 'LLL'. This can be done in linear time.

\paragraph{552}
There are two methods.
\begin{itemize}
\item First, this could be solved by dynamic programming. Let $d[i]$ be the number of possible rewardable records that do not contain 'A' and
have length $i$. Then the recurrsive transformation is $d[i] = d[i-1] + d[i-2] + d[i-3]$, which means the records of length $i$
can be obtained by adding 'P', 'PL' or 'PLL' at the end of a record of length $i-1$, $i-2$ or $i-3$ respectively.
After that, we just need to count the number of records that contains one 'A', which is the sum of $d[i] * d[n-i-1]$ for all
$i>=0$. The running time is $O(n)$. 

\item This could also be solved by using matrix multiplication. We define a vector $f[i][j][k]$ that stores the number of 
rewardable records that have length $i$ and have exactly $j$ of 'A' and $k$ of 'L' at the end. Then we can find the following
relation: $f[i] = A * f[i-1]$, where $A$ is the matrix:
\[A=\left[ 
\begin{array}{cccccc}
1 & 1 & 1 & 0 & 0 & 0 \\ 
1 & 0 & 0 & 0 & 0 & 0 \\ 
0 & 1 & 0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 \\
\end{array} \right]. \]
Then we can compute the final vector $f[n]$ by using fast exponentiation by squaring. The running time is $O(\log n)$.
\end{itemize}


\paragraph{553}
There are two ways to solve this problem. One is to enumerate all the possible expressions and find the best, and the other
is to prove the best express always has the same form. We will show both methods.
\begin{itemize}
\item First, we show enumeration method. The idea is divide and conquer. We enumerate the position (that is the index of the array) 
$i$ to divide the array into two parts and compute the possible
max and min results of the two parts. Then we can obtain the possible max and min results of the whole array. Now we only need
to care about how to add parenthesis. We can store the expression string for the results of two subarrays and combine them 
to obtain the expression string of results of the whole array. Assume the position $i$ is not the last one. Then there are
division after this position that are operated before the division at $i$. So we need to add parenthesis to the right part of
$i$. If $i$ is the last one position, then we don't need to add parenthesis. The running time for this will be $O(n!)$, which
could be improved by memorization into $O(n^3)$.

\item The second method is to prove the best expression should always be the form $a / (b / c / d / \dots / z)$.
The proof is by induction. The hypothesis assumption is that for $k>2$ numbers, the max expression is $a_0 / (a_1 / a_2 / \dots
/ a_{k-1})$ and the min expression is $a_0 / a_1 / a_2 / \dots / a_{k-1}$.
The base case is when $k = 3$. For any $k+1$ numbers, suppose the assumption is correct for any $x <= k$ numbers. Now consider the
position $i$ for the last division operation. No matter where $i$ is, the left part has the max form and the right part has the 
min form, which can be combined into the max form of the whole sequence. Q.E.D.
\end{itemize}


\paragraph{554}
If the line crosses least bricks, then that is where most lines can be split. That is, we want to find a number that can split
most rows. For each row, the number is the sum of the bricks on the left of the line. We count such sums for all rows in 
a dictionary and choose the max value. The running time is linear to the number of bricks.

\paragraph{555}
We enumerate each possible position as the cut point and then choose the best among them as result. 
First we need to preprocess the strings so that each string is the max between its current order and its reverse order.
This is because when the cut point is not in a string $s$, it should always be chosen in the order that forms a larger string.
For the string that contains the cut point, we try all cut points in the two orders. The running time is $O(n^2)$. 

\paragraph{556}
Similar to find the next permutation. Transform the number into a list of digits. 
Find the longest increasing sequence from the end and then process this sequence.
Assume this sequence is $A[i:]$, then find the smallest element $A[j]$ in this sequence that is larger than $A[i-1]$ and swap
them. Next, sort $A[i:]$ and transform the list back to the number. Take care of the corner case.

\paragraph{557}
String processing. Split the intput into words, reverse the words and then join them by space.

\paragraph{560}
This can be solved by hashmap. For each index $i$, we could have a sum, denoted by $s_i$ for the previous $i$ numbers. 
For each such sum, we record the number of such indices. 
That is, $index[s]$ stores the number of indices $i$ we have seen such that $s_i$ is equal to $s$.
Then for each number $x$ in the array, we just need to add the number of $index[k-x]$ to our answer.
The running time is linear to the length of the array.




\paragraph{561}
Sort the array and then sum the numbers with even indices, since these will be the minimum of the pair. 
This runs in $O(n \log n)$ time.

\paragraph{562}
We could simply check each row, each column, each diagonal and each anti-diagonal to count the longest line. Or we could just
memory those values for each cell if there is one in it and then iteratively compute all four values for all cells and choose
the maximum of them. Both methods runs in linear time to the number of cells.

\paragraph{563}
Recursively compute the sum of the values and the tilt of the subtree rooted at current node. This runs in linear time.

\paragraph{564}
The closest palindrome could either has the same number of digits as $n$ or not. If not, then the answer is either of the form
$100 \dots 001$ or the form $99\dots99$. For example, the answer for 10 is 9, and the answer for 99 is 101. 
If they have the same number of digits, then the right part needs to be the same as the left part except for the middle one
or two digits. This make sure the change is minimized. For the middle one or two digits, we just need to check +1, -1 and
itself (if two digits then check the left and assign the right the same value), since other change will increase the absolute 
difference. We collect all possible values and then choose from these the nearest one as result. 
The running time is linear to the length of the given number.


\paragraph{566}
We can copy the elements from the given matrix to the resulting matrix. An interesting way to do this is using $i/c$ and $i \%
c$ for $0 \le i \le r * c$. The running time is linear to the number of elements.

\paragraph{567}
This problem can be solved by sliding window or two pointers.
To check the permutation, we only need to count the number of each letters in a given substring, which can be represented by an 
counting array of length 26.
For sliding window, we try each substring in $s2$ to see if the counting array is the same as that of $s1$.
For each sliding or movement of the index, we only need to change the counting array for the first letter and end letter, which
can be done in constant time.
For two pointers $start$ and $end$, we make sure the substring of $(start, end]$ contains the same letters as $s1$. So when the 
distance between the two pointers is the same as the length of $s1$, we find the right substring. To make sure the invariant, 
we do similar thing as sliding window. First find the counting array for $s1$. Then we check the new letter at index $end$: if
there are more such letter in $s1$ then our current substring, then we subtract 1 for this letter in the counting array; else
we move the $start$ index forward until we find a letter the same as $end$.
Now $end$ can move again.
The running time is linear to the length of $s2$ since the two methods just remove the two index positions in $s2$.

\paragraph{568}
This probelm can be solved by dynamic programming.
We use $dp[i][j]$ to store the max number of vacation days we can obtain in first $i-1$ weeks and ending at the $j$-th city.
Then we have $dp[i][j] = \max_{flights[x][j] == 1 || x == j} \{ dp[i][j], dp[i-1][x] + days[j][i] \}$. 
That is, we can try all possible ways to reach $j$-th city and get the max number of vacation days.
The running time is $O(n^2 k)$.



\end{document}
